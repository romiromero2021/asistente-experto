# -*- coding: utf-8 -*-
"""Untitled44.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kJqBVZBI3jzRL60X9PyKtrzKJBiJo7Zv
"""

import streamlit as st
import io
import os
import openai
from openai import OpenAI
import PyPDF2
from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
import datetime
import base64
import re
from collections import defaultdict

class AsistenteEnergetico:
    def __init__(self, api_key):
        self.client = OpenAI(api_key=api_key)
        self.documentos = {
            '1': {
                'nombre': 'Informe de Electrificación Rural Guatemala',
                'archivo': 'INFORME_ELECTRIFICACION_RURAL_GT.pdf'
            },
            '2': {
                'nombre': 'Cocción de Alimentos Guatemala y Honduras',
                'archivo': 'COCCION_ALIMENTOS_GT_HN.pdf'
            },
            '3': {
                'nombre': 'Acceso a Energía Moderna Honduras',
                'archivo': 'ACCESO_ENERGIA_MODERNA_HN.pdf'
            },
            '4': {
                'nombre': 'Informe UPE Guatemala',
                'archivo': 'INFORME_UPE_GT.pdf'
            }
        }

        self.contexto_sistema = """Eres un experto en temas energéticos, específicamente en:
        - Electrificación rural
        - Cocción de alimentos y uso de energía
        - Acceso a energía moderna
        - Políticas energéticas

        Tu tarea es analizar documentos sobre estos temas y responder preguntas de manera detallada y precisa,
        citando información específica de los documentos cuando sea relevante. Para resúmenes, debes incluir:
        - Objetivo principal del documento
        - Metodología utilizada
        - Principales hallazgos
        - Conclusiones clave
        - Recomendaciones principales

        Cuando respondas preguntas específicas, asegúrate de:
        1. Citar las secciones específicas del documento que respaldan tu respuesta
        2. Proporcionar contexto relevante
        3. Mencionar datos cuantitativos cuando estén disponibles
        4. Explicar cualquier terminología técnica utilizada"""

    def procesar_texto_para_analisis(self, texto):
        """Procesa el texto del documento para mejor análisis"""
        # Dividir el texto en secciones más manejables
        secciones = []
        current_section = ""
        lines = texto.split('\n')

        for line in lines:
            current_section += line + '\n'
            if len(current_section) > 2000:  # Chunks de aproximadamente 2000 caracteres
                secciones.append(current_section)
                current_section = ""

        if current_section:
            secciones.append(current_section)

        return secciones

    def buscar_contexto_relevante(self, pregunta, texto_completo):
        """Busca secciones relevantes del texto para la pregunta"""
        secciones = self.procesar_texto_para_analisis(texto_completo)

        # Preprocesar la pregunta para identificar palabras clave
        palabras_clave = set(re.findall(r'\w+', pregunta.lower()))

        # Eliminar palabras comunes poco significativas
        palabras_comunes = {'el', 'la', 'los', 'las', 'un', 'una', 'unos', 'unas', 'y', 'o', 'de', 'del', 'que', 'en', 'por'}
        palabras_clave = palabras_clave - palabras_comunes

        # Puntuar cada sección según relevancia
        secciones_relevantes = []
        for seccion in secciones:
            puntuacion = 0
            texto_seccion = seccion.lower()

            # Contar apariciones de palabras clave
            for palabra in palabras_clave:
                puntuacion += texto_seccion.count(palabra)

            if puntuacion > 0:
                secciones_relevantes.append((seccion, puntuacion))

        # Ordenar por relevancia y seleccionar las más importantes
        secciones_relevantes.sort(key=lambda x: x[1], reverse=True)

        # Tomar las secciones más relevantes hasta un límite de tokens
        contexto_relevante = ""
        total_caracteres = 0
        for seccion, _ in secciones_relevantes:
            if total_caracteres + len(seccion) < 6000:  # Límite aproximado para mantener dentro de los límites de tokens
                contexto_relevante += seccion + "\n\n"
                total_caracteres += len(seccion)
            else:
                break

        return contexto_relevante

    def generar_resumen(self, texto_documento, nombre_documento):
        """Genera un resumen estructurado del documento"""
        try:
            # Procesar el documento completo en secciones
            secciones = self.procesar_texto_para_analisis(texto_documento)
            resumen_completo = ""

            # Analizar cada sección y construir el resumen
            for i, seccion in enumerate(secciones):
                prompt = f"""
                Analiza la siguiente sección ({i+1}/{len(secciones)}) del documento: {nombre_documento}

                Texto de la sección:
                {seccion}

                Identifica y extrae:
                1. Objetivos o propósitos mencionados
                2. Metodología descrita
                3. Hallazgos importantes
                4. Conclusiones relevantes
                5. Recomendaciones específicas

                Proporciona la información en formato estructurado.
                """

                response = self.client.chat.completions.create(
                    model="gpt-4",
                    messages=[
                        {"role": "system", "content": self.contexto_sistema},
                        {"role": "user", "content": prompt}
                    ],
                    temperature=0.7,
                    max_tokens=1000
                )

                resumen_seccion = response.choices[0].message.content
                resumen_completo += resumen_seccion + "\n\n"

            # Sintetizar el resumen final
            prompt_final = f"""
            Sintetiza los siguientes análisis parciales en un resumen cohesivo y estructurado:

            {resumen_completo}

            El resumen final debe estar organizado en:
            1. Objetivo principal
            2. Metodología
            3. Hallazgos principales
            4. Conclusiones clave
            5. Recomendaciones
            """

            response_final = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": self.contexto_sistema},
                    {"role": "user", "content": prompt_final}
                ],
                temperature=0.7,
                max_tokens=2000
            )

            return response_final.choices[0].message.content

        except Exception as e:
            st.error(f"Error al generar resumen: {str(e)}")
            return None

    def generar_respuesta(self, pregunta, texto_documento, nombre_documento):
        """Genera una respuesta usando GPT-4"""
        try:
            if "resumen" in pregunta.lower():
                return self.generar_resumen(texto_documento, nombre_documento)

            # Buscar contexto relevante para la pregunta
            contexto_relevante = self.buscar_contexto_relevante(pregunta, texto_documento)

            prompt = f"""
            Analiza la siguiente información del documento: {nombre_documento}

            Pregunta específica: {pregunta}

            Contexto relevante del documento:
            {contexto_relevante}

            Proporciona una respuesta detallada que:
            1. Responda directamente a la pregunta
            2. Cite secciones específicas del documento
            3. Incluya datos cuantitativos cuando estén disponibles
            4. Explique cualquier término técnico utilizado
            5. Proporcione contexto adicional relevante

            Estructura tu respuesta de manera clara y organizada.
            """

            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": self.contexto_sistema},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=2000
            )

            return response.choices[0].message.content
        except Exception as e:
            st.error(f"Error al generar respuesta: {str(e)}")
            return None

    def crear_documento_respuesta(self, pregunta, respuesta, nombre_documento):
        """Crea un documento Word con la respuesta"""
        doc = Document()

        # Estilos
        styles = doc.styles
        style = styles['Normal']
        font = style.font
        font.name = 'Calibri'
        font.size = Pt(11)

        # Título
        titulo = doc.add_heading('Análisis de Documento Energético', 0)
        titulo.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # Información del documento
        doc.add_heading('Información General', 1)
        p = doc.add_paragraph()
        p.add_run('Documento analizado: ').bold = True
        p.add_run(nombre_documento)
        p = doc.add_paragraph()
        p.add_run('Fecha de consulta: ').bold = True
        p.add_run(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        # Pregunta
        doc.add_heading('Pregunta Realizada', 1)
        doc.add_paragraph(pregunta)

        # Respuesta
        doc.add_heading('Respuesta', 1)
        # Procesar la respuesta por secciones
        secciones = respuesta.split('\n\n')
        for seccion in secciones:
            if seccion.strip():
                # Detectar si es un título
                if seccion.strip().endswith(':') or seccion.strip().isupper():
                    doc.add_heading(seccion.strip(), 2)
                else:
                    # Detectar si es una lista
                    if seccion.strip().startswith(('•', '-', '*')):
                        items = seccion.split('\n')
                        for item in items:
                            if item.strip():
                                doc.add_paragraph(item.strip(), style='List Bullet')
                    else:
                        doc.add_paragraph(seccion.strip())

        # Pie de página
        doc.add_paragraph('\n')
        footer = doc.sections[0].footer
        footer_para = footer.paragraphs[0]
        footer_para.text = f"Generado por Asistente Energético GPT - {datetime.datetime.now().strftime('%Y-%m-%d')}"
        footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # Guardar documento en memoria
        docx_stream = io.BytesIO()
        doc.save(docx_stream)
        docx_stream.seek(0)
        return docx_stream

def main():
    st.set_page_config(
        page_title="Asistente Energético GPT",
        page_icon="⚡",
        layout="wide"
    )

    st.title("Asistente Energético GPT")
    st.markdown("---")

    # Sidebar para la configuración
    st.sidebar.title("Configuración")

    # API Key input en el sidebar
    api_key = st.sidebar.text_input("Ingrese su API key de OpenAI", type="password")

    if not api_key:
        st.warning("Por favor, ingrese su API key de OpenAI para continuar.")
        return

    # Inicializar el asistente
    asistente = AsistenteEnergetico(api_key)

    # Área principal
    col1, col2 = st.columns([1, 2])

    with col1:
        st.subheader("Selección de Documento")
        # Crear lista de documentos para el selectbox
        opciones_documentos = {doc['nombre']: key for key, doc in asistente.documentos.items()}
        documento_seleccionado = st.selectbox(
            "Escoja un documento para analizar:",
            options=list(opciones_documentos.keys())
        )

        # Subir archivo
        st.subheader("Cargar Documento")
        archivo_subido = st.file_uploader("Suba el archivo PDF correspondiente", type=['pdf'])

    with col2:
        if archivo_subido is not None:
            st.subheader("Realizar Consulta")

            # Extraer texto del PDF
            pdf_reader = PyPDF2.PdfReader(archivo_subido)
            texto_documento = ""
            for pagina in pdf_reader.pages:
                texto_documento += pagina.extract_text() + "\n"

            # Área de pregunta
            tipo_consulta = st.radio(
                "Tipo de consulta:",
                ["Resumen del documento", "Pregunta específica"]
            )

            if tipo_consulta == "Pregunta específica":
                pregunta = st.text_area("Escriba su pregunta:")
            else:
                pregunta = "resumen"

            if st.button("Generar respuesta"):
                with st.spinner("Analizando documento y generando respuesta..."):
                    # Obtener respuesta
                    respuesta = asistente.generar_respuesta(
                        pregunta,
                        texto_documento,
                        documento_seleccionado
                    )

                    if respuesta:
                        st.markdown("### Respuesta:")
                        st.markdown(respuesta)

                        # Generar documento Word
                        docx_stream = asistente.crear_documento_respuesta(
                            pregunta,
                            respuesta,
                            documento_seleccionado
                        )

                        # Botón de descarga
                        st.download_button(
                            label="Descargar respuesta como documento Word",
                            data=docx_stream.getvalue(),
                            file_name=f'Respuesta_{datetime.datetime.now().strftime("%Y%m%d_%H%M%S")}.docx',
                            mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                        )

if __name__ == "__main__":
    main()